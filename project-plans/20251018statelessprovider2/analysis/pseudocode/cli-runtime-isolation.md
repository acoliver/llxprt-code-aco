<!-- @plan:PLAN-20251018-STATELESSPROVIDER2.P13 @requirement:REQ-SP2-003 -->
1: Initialise `RuntimeIsolationManager` that records active runtimeIds, allocates scoped dependency containers, and exposes `prepareRuntime(commandArgs)` so each CLI invocation receives a freshly constructed context detached from global singletons.
2: Within `prepareRuntime`, clone baseline CLI configuration, hydrate environment-derived defaults, and attach per-runtime telemetry/log buffers that flush only when the runtime completes to avoid cross-talk between concurrent invocations.
3: Route parsed CLI input through `dispatchIsolatedCommand` which resolves the command handler, injects the scoped runtime context, and wraps execution with `activateScopedRuntime` / `disposeScopedRuntime` guards to ensure resources are released even on failure.
4: For `/provider`, use the isolated context to enumerate registered providers, performing selection mutations exclusively against the scoped settings snapshot, then persist changes back through a transactional commit so simultaneous sessions do not overwrite each other.
5: For `/model`, read available models through the scoped provider gateway, validate compatibility against the runtime's provider selection, and update the runtime-limited settings cache without touching the host application's default model reference.
6: For `/set`, merge key/value overrides into the scoped configuration, emit change events only within the runtime, and stage persistence records that `disposeScopedRuntime` will later reconcile with shared storage under a conflict-aware merge.
7: For `/profile`, load and update profile data inside the isolated runtime store, materialising credentials or preferences into the scoped secret manager so profile switches remain invisible to other active runtimes until commit.
8: For `/baseurl`, resolve base URL overrides inside the scoped provider client factory, rebuild the runtime-specific HTTP client, and defer any global registry updates until the isolation layer verifies there are no competing modifications.
9: For `/key`, prompt, validate, and encrypt API keys inside the runtime's credential vault, ensuring only a runtime-limited vault handle is exposed while a sealed write-back payload is queued for the post-run reconciliation phase.
10: For `/keyfile`, stream file contents into the scoped secret importer, map resolved keys into the runtime credential vault, and schedule secure shredding of temporary file artifacts before `disposeScopedRuntime` publishes the consolidated credential set.
